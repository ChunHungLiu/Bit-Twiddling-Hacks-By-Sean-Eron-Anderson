* Contents
  * [About the operation counting methodology](#OperationCounting)
  * [Compute the sign of an integer](#CopyIntegerSign)
  * [Detect if two integers have opposite signs](#DetectOppositeSigns)
  * [Compute the integer absolute value (abs) without branching](#IntegerAbs)
  * [Compute the minimum (min) or maximum (max) of two integers without branching](#IntegerMinOrMax)
  * [Determining if an integer is a power of 2](#DetermineIfPowerOf2)
  * Sign extending
      * [Sign extending from a constant bit-width](#FixedSignExtend)
      * [Sign extending from a variable bit-width](#VariableSignExtend)
      * [Sign extending from a variable bit-width in 3 operations](#VariableSignExtendRisky)
  * [Conditionally set or clear bits without branching](#ConditionalSetOrClearBitsWithoutBranching)
  * [Conditionally negate a value without branching](#ConditionalNegate)
  * [Merge bits from two values according to a mask](#MaskedMerge)
  * Counting bits set
      * [Counting bits set, naive way](#CountBitsSetNaive)
      * [Counting bits set by lookup table](#CountBitsSetTable)
      * [Counting bits set, Brian Kernighan's way](#CountBitsSetKernighan)
      * [Counting bits set in 14, 24, or 32-bit words using 64-bit instructions](#CountBitsSet64)
      * [Counting bits set, in parallel](#CountBitsSetParallel)
      * [Count bits set (rank) from the most-significant bit upto a given position](#CountBitsFromMSBToPos)
      * [Select the bit position (from the most-significant bit) with the given count (rank)](#SelectPosFromMSBRank)
  * Computing parity (1 if an odd number of bits set, 0 otherwise)
      * [Compute parity of a word the naive way](#ParityNaive)
      * [Compute parity by lookup table](#ParityLookupTable)
      * [Compute parity of a byte using 64-bit multiply and modulus division](#ParityWith64Bits)
      * [Compute parity of word with a multiply](#ParityMultiply)
      * [Compute parity in parallel](#ParityParallel)
  * Swapping Values
      * [Swapping values with subtraction and addition](#SwappingValuesSubAdd)
      * [Swapping values with XOR](#SwappingValuesXOR)
      * [Swapping individual bits with XOR](#SwappingBitsXOR)
  * Reversing bit sequences
      * [Reverse bits the obvious way](#BitReverseObvious)
      * [Reverse bits in word by lookup table](#BitReverseTable)
      * [Reverse the bits in a byte with 3 operations (64-bit multiply and modulus division)](#ReverseByteWith64BitsDiv)
      * [Reverse the bits in a byte with 4 operations (64-bit multiply, no division)](#ReverseByteWith64Bits)
      * [Reverse the bits in a byte with 7 operations (no 64-bit, only 32)](#ReverseByteWith32Bits)
      * [Reverse an N-bit quantity in parallel with 5 * lg(N) operations](#ReverseParallel) 
  * Modulus division (aka computing **remainders**)
      * [Computing modulus division by 1 &lt;&lt; s without a division operation (obvious)](#ModulusDivisionEasy)
      * [Computing modulus division by (1 &lt;&lt; s) - 1 without a division operation](#ModulusDivision)
      * [Computing modulus division by (1 &lt;&lt; s) - 1 in parallel without a division operation](#ModulusDivisionParallel)
  * Finding integer log base 2 of an integer (aka the position of the highest bit set)
      * [Find the log base 2 of an integer with the MSB N set in O(N) operations (the obvious way)](#IntegerLogObvious)
      * [Find the integer log base 2 of an integer with an 64-bit IEEE float](#IntegerLogIEEE64Float)
      * [Find the log base 2 of an integer with a lookup table](#IntegerLogLookup)
      * [Find the log base 2 of an N-bit integer in O(lg(N)) operations](#IntegerLog)
      * [Find the log base 2 of an N-bit integer in O(lg(N)) operations with multiply and lookup](#IntegerLogDeBruijn)
  * [Find integer log base 10 of an integer](#IntegerLog10)
  * [Find integer log base 10 of an integer the obvious way](#IntegerLog10Obvious)
  * [Find integer log base 2 of a 32-bit IEEE float](#IntegerLogFloat)
  * [Find integer log base 2 of the pow(2, r)-root of a 32-bit IEEE float (for unsigned integer r)](#IntegerLogRootFloat)
  * Counting consecutive trailing zero bits (or finding bit indices)
      * [Count the consecutive zero bits (trailing) on the right linearly](#ZerosOnRightLinear)
      * [Count the consecutive zero bits (trailing) on the right in parallel](#ZerosOnRightParallel)
      * [Count the consecutive zero bits (trailing) on the right by binary search](#ZerosOnRightBinSearch)
      * [Count the consecutive zero bits (trailing) on the right by casting to a float](#ZerosOnRightFloatCast)
      * [Count the consecutive zero bits (trailing) on the right with modulus division and lookup](#ZerosOnRightModLookup)
      * [Count the consecutive zero bits (trailing) on the right with multiply and lookup](#ZerosOnRightMultLookup)
  * [Round up to the next highest power of 2 by float casting](#RoundUpPowerOf2Float)
  * [Round up to the next highest power of 2](#RoundUpPowerOf2)
  * Interleaving bits (aka computing **Morton Numbers**)
      * [Interleave bits the obvious way](#InterleaveTableObvious)
      * [Interleave bits by table lookup](#InterleaveTableLookup)
      * [Interleave bits with 64-bit multiply](#Interleave64bitOps)
      * [Interleave bits by Binary Magic Numbers](#InterleaveBMN)
  * Testing for ranges of bytes in a word (and counting occurances found)
      * [Determine if a word has a zero byte](#ZeroInWord)
      * [Determine if a word has a byte equal to n](#ValueInWord)
      * [Determine if a word has byte less than n](#HasLessInWord)
      * [Determine if a word has a byte greater than n](#HasMoreInWord)
      * [Determine if a word has a byte between m and n](#HasBetweenInWord)
  * [Compute the lexicographically next bit permutation](#NextBitPermutation)
